#include "Grid.h"

//constexpr auto grille =
//"       "
//" H    G"
//"       ";

Grid::Grid()
{	
	char grid[4][15][15] = {
		{
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'G', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{'H', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', 'S', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '}
		},
		{
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', 'H', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', 'G', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'F', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '}
		},
		{
			{' ', ' ', 'F', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'G', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', 'G', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', 'S', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'H'},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '}
		},
		{
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', 'F', 'F', 'F', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', 'F', ' ', ' ', ' ', 'F', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', 'F', ' ', ' ', ' ', ' ', ' ', 'F', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', 'F', ' ', ' ', ' ', ' ', ' ', 'F', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', 'F', ' ', ' ', 'H', ' ', ' ', 'F', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', 'F', ' ', ' ', ' ', ' ', ' ', 'F', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', 'F', ' ', ' ', ' ', ' ', ' ', 'F', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', 'F', ' ', ' ', ' ', 'F', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', 'F', 'F', 'F', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
			{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '}
		}
	};

	hero.m_pos = { 7, 0 };
	hero.m_character = 'H';

	for (int i = 0; i < levelCount; i++) {
		for (int j = 0; j < size; j++) {
			for (int k = 0; k < size; k++) {
				m_grid[i][j][k] = grid[i][j][k];
			}
		}
	}
}

void Grid::SetGridSize(int newSize)
{
	m_size = newSize;
}

bool Grid::CheckDistanceToEntity(std::vector<int> position, int distance, Entity entity)
{
	return std::abs(entity.m_pos[0] - position[0]) + std::abs(entity.m_pos[1] - position[1]) <= distance;
}

void Grid::PrintGrid()
{
	PrintWall();
	for (int line = 0; line < m_size; line++) {
		PrintLine(line);
		PrintWall();
	}
}

void Grid::PrintLine(int line)
{
		std::cout << "\033[48;5;235m|\033[0m";
		for (int column = 0; column < m_size; column++) {
			if (CheckDistanceToEntity({ line, column }, 1, hero) && m_grid[currentLevel][line][column] == ' ') {
				std::cout << "\033[44m";
			}
			else {
				std::cout << "\033[48;5;235m";
			}
			Tile tile(m_grid[currentLevel][line][column]);
			std::cout << "\033[48;5;235m|\033[0m";
		}
		std::cout << std::endl;
}

void Grid::PrintWall()
{
	std::cout << "\033[48;5;235m+\033[0m";
	for (int i = 0; i < m_size; i++) {
		std::cout << "\033[48;5;235m---+\033[0m";
	}
	std::cout << std::endl;
}

bool Grid::Move(std::vector<int> movement, Entity& entity)
{
	return SwapSymbol(entity, movement);
}

bool Grid::SwapSymbol(Entity& entity, std::vector<int> movement)
{
	if (entity.m_pos[0] + movement[0] < 0 || entity.m_pos[0] + movement[0] >= m_size || entity.m_pos[1] + movement[1] < 0 || entity.m_pos[1] + movement[1] >= m_size)
		return false;

	if (m_grid[currentLevel][entity.m_pos[0] + movement[0]][entity.m_pos[1] + movement[1]] != ' ')
		return false;

	m_grid[currentLevel][entity.m_pos[0]][entity.m_pos[1]] = ' ';
	entity.m_pos[0] += movement[0];
	entity.m_pos[1] += movement[1];
	m_grid[currentLevel][entity.m_pos[0]][entity.m_pos[1]] = entity.m_character;
	return true;
}

void Grid::SetNewHeroPos()
{
	for (int i = 0; i < size; i++) {
		for (int j = 0; j < size; j++) {
			if (m_grid[currentLevel][i][j] == 'H') {
				hero.m_pos = { i, j };
				std::cout << i << j;
			}
		}
	}
}


void Grid::ChangeLevel()
{
	currentLevel++;
	SetNewHeroPos();
}

char Grid::GetCharacter(std::vector<int> pos)
{
	return m_grid[currentLevel][pos[0]][pos[1]];
}

void Grid::ClearTile(std::vector<int> position)
{
	m_grid[currentLevel][position[0]][position[1]] = ' ';
}

int Grid::GetLevelCount()
{
	return sizeof(m_grid) / sizeof(m_grid[0]);
}
